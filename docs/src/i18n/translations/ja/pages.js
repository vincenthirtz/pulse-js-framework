/**
 * Japanese translations - Page content
 */

export default {
  // Home page
  home: {
    title: '⚡ Pulse Framework',
    tagline: 'CSSセレクター構文による宣言的DOMフレームワーク',
    features: {
      zeroDeps: '0️⃣ 依存関係ゼロ',
      uniqueSyntax: '🎯 独自の構文',
      reactive: '⚡ リアクティブ',
      smallBundle: '📦 コア約4kb',
      noBuild: '🔧 ビルド不要',
      mobile: '📱 モバイルアプリ'
    },
    getStarted: 'はじめる →',
    viewExamples: 'サンプルを見る',
    whatMakesUnique: 'Pulseの特徴は？',
    quickExample: 'クイックサンプル',
    pulseSyntax: '.pulse構文',
    jsEquivalent: 'JavaScript相当',
    stats: {
      gzipped: '圧縮済み',
      dependencies: '依存関係',
      buildTime: 'ビルド時間',
      a11yBuiltIn: 'A11y内蔵'
    },
    quickStart: {
      title: 'クイックスタート',
      desc: '1つのコマンドで数秒で開始できます。',
      terminal: 'ターミナル',
      copy: 'コピー',
      copied: 'コピーしました！',
      createProject: '新しいプロジェクトを作成',
      navigate: 'プロジェクトに移動',
      startDev: '開発サーバーを起動'
    },
    whyPulse: {
      title: 'なぜPulseを選ぶのか？',
      performance: {
        title: 'パフォーマンス',
        desc: '最小限のオーバーヘッドで細かいリアクティビティ。仮想DOMのdiffは不要。'
      },
      simplicity: {
        title: 'シンプルさ',
        desc: '直感的なCSSセレクター構文。少ないコードで多くを実現。'
      },
      accessibility: {
        title: 'アクセシビリティ',
        desc: '組み込みのa11yヘルパー、自動ARIA属性、監査ツール。'
      },
      mobile: {
        title: 'モバイル対応',
        desc: 'ネイティブモバイルブリッジ内蔵。iOSとAndroidアプリを直接構築。'
      },
      noBuild: {
        title: 'ビルド不要',
        desc: 'ブラウザで直接動作。最適化のためのビルドステップはオプション。'
      },
      security: {
        title: 'セキュリティ優先',
        desc: 'XSS保護、URL無害化、プロトタイプ汚染防止を内蔵。'
      }
    },
    comparison: {
      feature: '機能',
      uiStructure: 'UI構造',
      cssSelectors: 'CSSセレクター',
      reactivity: 'リアクティビティ',
      pulses: 'パルス',
      buildStep: 'ビルドステップ',
      bundleSize: 'バンドルサイズ',
      dependencies: '依存関係',
      buildSpeed: 'ビルド速度',
      learningCurve: '学習曲線',
      fileExtension: 'ファイル拡張子',
      mobileApps: 'モバイルアプリ',
      typescript: 'TypeScript',
      required: '必須',
      optional: 'オプション',
      many: '多い',
      some: 'いくつか',
      few: '少ない',
      zero: 'ゼロ',
      slow: '遅い',
      medium: '中程度',
      fast: '速い',
      instant: '即時',
      steep: '急',
      moderate: '緩やか',
      easy: '簡単',
      minimal: '最小限',
      builtIn: '組み込み',
      accessibility: 'アクセシビリティ',
      thirdParty: 'サードパーティ'
    }
  },

  // Getting Started page
  gettingStarted: {
    title: '🚀 はじめに',
    installation: 'インストール',
    installationDesc: '1つのコマンドで新しいPulseプロジェクトを作成：',
    manualSetup: '手動セットアップ',
    manualSetupDesc: 'または任意のプロジェクトで手動でセットアップ：',
    thenImport: 'JavaScriptでインポート：',
    firstComponent: '最初のコンポーネント',
    firstComponentDesc: 'シンプルなリアクティブカウンターを作成：',
    usingPulseFiles: '.pulseファイルの使用',
    usingPulseFilesDesc: 'よりクリーンな構文には、Viteプラグインで<code>.pulse</code>ファイルを使用：',
    projectStructure: 'プロジェクト構造',
    cliCommands: 'CLIコマンド',
    cliCommandsDesc: 'Pulseは開発ワークフロー用の完全なCLIを提供：',
    development: '開発',
    codeQuality: 'コード品質',
    lintChecks: '<strong>Lintチェック：</strong>未定義の参照、未使用のインポート/状態、命名規則、空のブロック、インポート順序。',
    formatRules: '<strong>フォーマットルール：</strong>2スペースインデント、ソートされたインポート、一貫したブレース、適切なスペーシング。',
    analyzeOutput: '<strong>分析出力：</strong>ファイル数、コンポーネントの複雑さ、インポートグラフ、デッドコード検出。',
    faq: 'よくある質問',
    faqBuildStep: {
      q: 'ビルドステップは必要ですか？',
      a: 'いいえ！Pulseはブラウザで直接動作します。ただし、<code>.pulse</code>ファイルと本番最適化には、Pulseプラグイン付きのViteの使用をお勧めします。'
    },
    faqComparison: {
      q: 'PulseはReact/Vueとどう比較されますか？',
      a: 'Pulseははるかに軽量（コア約4kb、フル約12kb対35-45kb）で、仮想DOMの代わりにパルス（リアクティブプリミティブ）を使用します。依存関係はゼロで、ビルドステップはオプションです。CSSセレクター構文はPulse独自のものです。'
    },
    faqTypeScript: {
      q: 'TypeScriptは使えますか？',
      a: 'はい！Pulseには完全なTypeScript定義が含まれています。<code>pulse-js-framework/runtime</code>から型をインポートするだけで、IDEがオートコンプリートを提供します。'
    },
    faqForms: {
      q: 'フォームはどう処理しますか？',
      a: '双方向バインディングには<code>model()</code>ヘルパーを使用：'
    },
    faqExisting: {
      q: '既存のプロジェクトでPulseを使えますか？',
      a: 'はい！Pulseは任意のDOM要素にマウントできます。<code>mount(\'#my-widget\', MyComponent())</code>を使用して、どこにでもPulseコンポーネントを埋め込めます。'
    },
    faqFetch: {
      q: 'データの取得はどうしますか？',
      a: 'エフェクトで標準の<code>fetch()</code>を使用：'
    },
    faqSSR: {
      q: 'PulseはSSRをサポートしていますか？',
      a: 'はい！v1.7.0以降、Pulseは<code>renderToString()</code>と<code>hydrate()</code>によるServer-Side Renderingをサポートしています。詳細は<a href="/ssr">SSRガイド</a>をご覧ください。'
    },
    faqDebug: {
      q: 'アプリのデバッグはどうしますか？',
      a: 'Pulse v1.4.9以降は<code>.pulse</code>ファイルのソースマップをサポートしています。構造化された出力にはLogger APIを使用してください。詳しくはデバッグガイドをご覧ください。'
    },
    faqMobile: {
      q: 'モバイルアプリを作れますか？',
      a: 'はい！<code>pulse mobile init</code>を使用してAndroid/iOSプロジェクトをセットアップします。Pulseにはストレージ、デバイス情報などのネイティブAPIが含まれています。モバイルガイドをご覧ください。'
    },
    faqHelp: {
      q: 'ヘルプはどこで得られますか？',
      a: 'GitHubでissueを開くか、参考実装のサンプルをチェックしてください。'
    },
    nextCoreConcepts: '次へ：コアコンセプト →'
  },

  // Core Concepts page
  coreConcepts: {
    title: '💡 コアコンセプト',
    pulses: 'パルス（リアクティブ状態）',
    pulsesDesc: 'パルスは値が変更されたときにサブスクライバーに通知するリアクティブコンテナです。',
    effects: 'エフェクト',
    effectsDesc: 'エフェクトは依存関係が変更されると自動的に実行されます。',
    cssSelectorSyntax: 'CSSセレクター構文',
    cssSelectorSyntaxDesc: 'おなじみのCSSセレクター構文でDOM要素を作成。',
    pulseFileSyntax: '.pulseファイル構文',
    pulseFileSyntaxDesc: '.pulse DSLは、コンポーネントを書くためのクリーンで宣言的な方法を提供します。',
    blocks: 'ブロック',
    imports: 'インポート',
    directives: 'ディレクティブ',
    slots: 'スロット（コンテンツ投影）',
    slotsDesc: 'スロットを使用して動的コンテンツでコンポーネントを構成。',
    cssScoping: 'CSSスコープ',
    cssScopingDesc: '.pulseファイル内のスタイルは自動的にコンポーネントにスコープされます。',
    advancedRouting: '高度なルーティング',
    advancedRoutingDesc: 'Pulseルーターは遅延読み込み、ミドルウェア、コード分割をサポート。',
    lazyLoading: '遅延読み込み',
    lazyLoadingDesc: '初期バンドルサイズを削減するためにルートコンポーネントをオンデマンドで読み込み。',
    middleware: 'ミドルウェア',
    middlewareDesc: '柔軟なナビゲーション制御のためのKoaスタイルミドルウェア。',
    nextApiReference: '次へ: APIリファレンス →'
  },

  // API Reference page
  apiReference: {
    title: '📖 APIリファレンス',
    searchPlaceholder: 'APIを検索...',
    filter: 'フィルター:',
    typescriptSupport: 'TypeScriptサポート',
    typescriptSupportDesc: 'PulseはIDE自動補完のための完全なTypeScript定義を含みます。',
    reactivity: 'リアクティビティ',
    reactivityDesc: 'シグナルベースのリアクティビティシステム。',
    domSection: 'DOM',
    domSectionDesc: 'DOM作成・操作のヘルパー。',
    routerSection: 'ルーター',
    routerSectionDesc: 'ネストルートとガード付きSPAルーター。',
    storeSection: 'ストア',
    storeSectionDesc: 'グローバル状態管理。',
    hmrSection: 'HMR',
    hmrSectionDesc: 'ホットモジュールリプレースメント。',
    resultsFound: '件見つかりました',
    noResults: '結果が見つかりません',
    nextMobile: '次: モバイルアプリ →',
    categories: {
      all: 'すべて',
      types: '型',
      reactivity: 'リアクティビティ',
      dom: 'DOM',
      router: 'ルーター',
      store: 'ストア',
      hmr: 'HMR'
    }
  },

  // Examples page
  examples: {
    title: '✨ サンプル',
    intro: 'Pulseの動作を確認するためのサンプルアプリケーションをご覧ください。',
    viewDemo: 'デモを見る →',
    viewSource: 'ソースを見る',
    hmrDemo: {
      title: 'HMRデモ',
      desc: '状態保持付きホットモジュールリプレースメント。',
      features: [
        'HMR中の状態保持',
        'エフェクトの自動クリーンアップ',
        'テーマ切り替え',
        'メモの永続化',
        'HMR更新カウンター'
      ]
    },
    blog: {
      title: '📰 ブログ',
      desc: 'CRUD、カテゴリ、検索機能付きの完全なブログアプリ。',
      features: [
        'CRUD操作',
        'カテゴリフィルタリング',
        '検索機能',
        'ライト/ダークモード',
        'レスポンシブデザイン'
      ]
    },
    todoApp: {
      title: '📝 Todoアプリ',
      desc: 'ダークモードと永続化付きの完全なTodoアプリ。',
      features: [
        '追加、編集、削除',
        'ステータスフィルター',
        'ダークモード',
        'LocalStorage永続化',
        '進捗トラッキング'
      ]
    },
    weatherApp: {
      title: '🌤️ 天気アプリ',
      desc: 'Open-Meteo APIを使用したリアルタイム天気アプリ。',
      features: [
        '都市検索',
        '現在の状況',
        '7日間予報',
        'お気に入り都市',
        '°C/°F切り替え'
      ]
    },
    ecommerce: {
      title: '🛒 ECショップ',
      desc: 'カートとチェックアウト付きの完全なショッピング体験。',
      features: [
        '商品カタログ',
        '検索とフィルター',
        'ショッピングカート',
        'チェックアウトフロー',
        'LocalStorage永続化'
      ]
    },
    chatApp: {
      title: '💬 チャットアプリ',
      desc: 'ルームとシミュレートユーザー付きリアルタイムメッセージング。',
      features: [
        '複数ルーム',
        'ユーザープレゼンス',
        'シミュレートボット返信',
        '絵文字ピッカー',
        'メッセージ永続化'
      ]
    },
    routerDemo: {
      title: '🧭 ルーターデモ',
      desc: 'ナビゲーション、ガード、動的ルート付きSPAルーティング。',
      features: [
        'ルートパラメータ',
        'クエリストリング',
        'ルートガード',
        'アクティブリンクスタイル',
        '保護されたルート'
      ]
    },
    storeDemo: {
      title: '📝 ストアデモ',
      desc: 'Pulseストアシステムによるグローバル状態管理。',
      features: [
        '永続化付きcreateStore',
        'アクションとゲッター',
        '元に戻す/やり直し',
        'モジュラーストア',
        'ロガープラグイン'
      ]
    },
    dashboard: {
      title: '📊 管理ダッシュボード',
      desc: 'すべての機能を実演する完全な管理インターフェース。',
      features: [
        '認証とガード',
        'チャート、テーブル、モーダル',
        'CRUD操作',
        'テーマと設定',
        'すべてのリアクティブ機能'
      ]
    },
    sportsNews: {
      title: '⚽ スポーツニュース',
      desc: 'HTTPクライアントとリアクティブデータ取得を備えたニュースアプリ。',
      features: [
        'HTTPクライアント統合',
        'カテゴリーフィルタリング',
        'デバウンス検索',
        'お気に入りシステム',
        'ダークモード'
      ]
    },
    lessDemo: {
      title: 'LESS CSS Demo',
      desc: '変数、ミックスイン、ガード、カラー関数を使用したLESSプリプロセッサーのサポートを実証。',
      features: [
        'LESS変数と演算',
        'ガード付きパラメトリックミックスイン',
        'カラー関数（明るく、暗く）',
        'ネスティングと親セレクター',
        'ダイナミックテーマ切り替え'
      ]
    },
    stylusDemo: {
      title: 'Stylus CSS Demo',
      desc: '柔軟な構文、ブレースなしのミックスイン、最小限の句読点を持つStylusプリプロセッサーを紹介。',
      features: [
        '$や@なしの変数',
        '柔軟な構文（ブレース不要）',
        'ミックスインとネスティング',
        '数学演算',
        'グラデーションとアニメーション'
      ]
    },
    webpackDemo: {
      title: 'Webpack統合',
      desc: 'HMR、CSS抽出、SASSプリプロセッシングを備えたPulse Webpackローダーのデモ。',
      features: [
        'Webpack 5ローダー統合',
        'ホットモジュールリプレースメント（HMR）',
        'style-loaderによるCSS抽出',
        'SASSプリプロセッシングサポート',
        'デバッグ用ソースマップ'
      ]
    },
    rollupDemo: {
      title: 'Rollup統合',
      desc: 'ツリーシェイキング、CSS抽出、最適化ビルドを備えたPulse Rollupプラグインのデモ。',
      features: [
        'Rollup 4+プラグイン統合',
        '個別ファイルへのCSS抽出',
        'ESモジュールツリーシェイキング',
        'SASSプリプロセッシングサポート',
        '開発用ウォッチモード'
      ]
    },
    parcelDemo: {
      title: 'Parcel統合',
      desc: 'ゼロ設定バンドリング、HMR、CSSプリプロセッシングを備えたPulse Parcelトランスフォーマーのデモ',
      features: [
        'Parcelトランスフォーマー統合',
        'ゼロ設定バンドリング',
        'ホットモジュール交換 (HMR)',
        'ParcelパイプラインへのCSS抽出',
        'SASS/LESS/Stylusサポート'
      ]
    },
    esbuildDemo: {
      title: 'ESBuild統合',
      desc: 'Pulse ESBuildプラグインで超高速ビルド、CSS抽出、ウォッチモードを表示。',
      features: [
        'ESBuildプラグイン統合',
        '超高速インクリメンタルビルド',
        'CSSを別ファイルに抽出',
        'SASSプリプロセッサのサポート',
        '組み込み開発サーバー'
      ]
    },
    runLocally: 'ローカルで実行',
    runLocallyDesc: 'マシンでサンプルプロジェクトを実行するには：',
    createYourOwn: '自分で作成',
    createYourOwnDesc: '新しいPulseプロジェクトを開始：',
    mobileExamples: '📱 モバイルサンプル',
    mobileExamplesDesc: 'PulseはWebView経由でモバイルプラットフォームでも実行できます。'
  },

  // Playground page
  playground: {
    title: '🎮 プレイグラウンド',
    intro: 'ブラウザでPulseを試してみましょう。コードを編集して結果を即座に確認できます。',
    codeEditor: '📝 コードエディター',
    preview: '👁️ プレビュー',
    run: '▶ 実行',
    reset: '↺ リセット',
    share: '共有',
    ready: '準備完了',
    running: '実行中...',
    success: '✓ 成功',
    errorPrefix: 'エラー:',
    templates: '📋 クイックテンプレート',
    templateCounter: 'カウンター',
    templateTodo: 'Todoリスト',
    templateTimer: 'タイマー',
    templateForm: 'フォーム',
    templateCalculator: '電卓',
    templateTabs: 'タブ',
    templateTheme: 'テーマ',
    templateSearch: '検索',
    templateCart: 'カート',
    templateAnimation: 'アニメーション'
  },

  // Debugging page
  debugging: {
    title: '🔍 デバッグ',
    intro: 'Pulseアプリケーションをデバッグするためのツールとテクニック。',
    sourceMaps: 'ソースマップ',
    sourceMapsDesc: 'Pulse v1.4.9以降は、コンパイルされた.pulseファイル用のV3ソースマップを生成します。',
    enablingSourceMaps: 'ソースマップの有効化',
    viteIntegration: 'Vite統合',
    viteIntegrationDesc: 'Viteプラグインは開発モードで自動的にソースマップを生成します。',
    usingSourceMaps: 'DevToolsでソースマップを使用',
    usingSourceMapsSteps: [
      'Chrome/Firefox DevToolsを開く（F12）',
      'Sourcesタブに移動',
      'ファイルツリーで.pulseファイルを見つける',
      '元のソース行にブレークポイントを設定',
      'エラースタックトレースは元の行番号を表示'
    ],
    loggerApi: 'Logger API',
    loggerApiDesc: '構造化されたデバッグ出力には組み込みロガーを使用。',
    logLevels: 'ログレベル',
    reactivityDebugging: 'リアクティビティデバッグ',
    reactivityDebuggingDesc: 'リアクティブ状態とエフェクトをデバッグするテクニック。',
    trackingDependencies: '依存関係の追跡',
    debuggingComputed: '計算値のデバッグ',
    batchDebugging: 'バッチデバッグ',
    routerDebugging: 'ルーターデバッグ',
    routerDebuggingDesc: 'ナビゲーションとルートマッチングのデバッグ。',
    hmrDebugging: 'HMRデバッグ',
    hmrDebuggingDesc: 'ホットモジュールリプレースメントの問題をデバッグ。',
    commonErrors: 'よくあるエラー',
    performanceProfiling: 'パフォーマンスプロファイリング',
    performanceProfilingDesc: 'ボトルネックを特定するためのヒント。',
    nextApiReference: '次へ: APIリファレンス →'
  },

  // Security page
  security: {
    title: '🔒 セキュリティ',
    intro: '安全なPulseアプリケーションを構築するためのベストプラクティス。',
    xssPrevention: 'XSS対策',
    xssPreventionDesc: 'クロスサイトスクリプティング（XSS）は最も一般的なWeb脆弱性の1つです。',
    safeByDefault: 'デフォルトで安全：テキストコンテンツ',
    safeByDefaultDesc: '文字列の子要素を持つel()関数は自動的にHTMLをエスケープします。',
    dangerousInnerHtml: '危険：innerHTML',
    dangerousInnerHtmlDesc: '信頼できないコンテンツにはinnerHTMLを使用しないでください。',
    safePatterns: '動的コンテンツの安全なパターン',
    urlSanitization: 'URLのサニタイズ',
    urlSanitizationDesc: 'ユーザー提供のURLは常にサニタイズしてください。',
    formSecurity: 'フォームセキュリティ',
    formSecurityDesc: 'フォームデータの安全な処理。',
    inputValidation: '入力検証',
    sensitiveData: '機密データ',
    csp: 'Content Security Policy',
    cspDesc: 'Pulseアプリケーション用の推奨CSPヘッダー。',
    apiSecurity: 'APIセキュリティ',
    apiSecurityDesc: 'データ取得の安全なパターン。',
    checklist: 'セキュリティチェックリスト',
    nextPerformance: '次へ: パフォーマンスガイド'
  },

  // Internals page
  internals: {
    title: '⚙️ フレームワーク内部構造',
    intro: 'Pulseのアルゴリズムと実装の詳細に深く入り込みます。コントリビューター、上級ユーザー、好奇心旺盛な方向け。',
    lisAlgorithm: 'リスト差分（LISアルゴリズム）',
    lisDesc: 'リアクティブリストが更新されると、PulseはDOM操作を最小化するために最長増加部分列（LIS）アルゴリズムを使用します。',
    whyLis: 'なぜLIS？',
    whyLisDesc: '重要なのは、一部の要素が既に正しい相対順序にあることです。移動不要な要素を特定することで、残りだけを再配置します。',
    lisOverview: 'アルゴリズム概要（O(n log n)）',
    lisOverviewDesc: 'アルゴリズムは二分探索を使用して、どのアイテムがそのまま残れるかを効率的に計算します：',
    reconciliationPhases: '調整フェーズ',
    phasesCaption: 'リスト更新フェーズとその計算量',
    phase: 'フェーズ',
    operation: '操作',
    complexity: '計算量',
    keyExtraction: 'アイテムを一意のキーにマッピング',
    diffPhase: '追加/削除/移動を識別',
    removePhase: 'DOMノードを削除',
    createPhase: 'DocumentFragmentでバッチ作成',
    lisPhase: '安定したアイテムを計算',
    reorderPhase: 'LIS外のアイテムを移動',
    performanceByCase: 'シナリオ別パフォーマンス',
    scenarioCaption: '更新タイプ別のDOM操作',
    scenario: 'シナリオ',
    domOps: 'DOM操作',
    notes: '備考',
    appendItems: 'アイテム追加',
    appendNote: '単一のDocumentFragment挿入',
    prependItems: 'アイテム先頭追加',
    prependNote: '既存アイテムはLIS内',
    removeItems: 'アイテム削除',
    removeNote: '移動不要',
    reverseList: 'リスト反転',
    reverseNote: 'LIS = 1、全て移動',
    randomShuffle: 'ランダムシャッフル',
    shuffleNote: '通常30-50%が移動',
    moveSingle: '単一アイテム移動',
    moveNote: 'LISがn-1アイテムをカバー',
    selectorCache: 'セレクターキャッシュ（LRU）',
    selectorCacheDesc: 'parseSelector()関数は繰り返しパースを最適化するためにLRUキャッシュを使用して結果をキャッシュします。',
    whyLru: 'なぜMapではなくLRU？',
    cacheComparisonCaption: 'キャッシュ戦略の比較',
    approach: 'アプローチ',
    memory: 'メモリ',
    longRunning: '長時間実行アプリ',
    noCache: 'キャッシュなし',
    minimal: '最小',
    unboundedMap: '無制限Map',
    growsForever: '無限に成長',
    memoryLeak: 'メモリリークリスク',
    bounded: '制限あり',
    hotCached: '頻繁なセレクターがキャッシュされる',
    cacheConfig: '設定',
    cacheSafety: 'キャッシュの安全性',
    cacheSafetyDesc: 'キャッシュはキャッシュ値の変更を防ぐためにシャローコピーを返します：',
    lruEviction: 'LRU追い出し動作',
    conditionalLifecycle: '条件付きレンダリングのライフサイクル',
    conditionalLifecycleDesc: 'when()とmatch()関数はメモリリークと古いサブスクリプションを防ぐためにエフェクトのクリーンアップを管理します。',
    cleanupGuarantees: 'クリーンアップ保証',
    nodesRemoved: 'DOMノード削除',
    nodesRemovedDesc: '前のブランチのノードがDOMから削除される',
    cleanupCalled: 'クリーンアップ関数呼び出し',
    cleanupCalledDesc: '前のレンダーが返したクリーンアップが実行される',
    stateReset: '状態リセット',
    stateResetDesc: '内部追跡配列がクリアされる',
    lifecycleDiagram: 'ライフサイクル図',
    whenVsShow: 'when() vs show() 比較',
    whenVsShowCaption: '条件付きレンダリング方法の選択',
    feature: '機能',
    domPresence: 'DOM存在',
    addsRemoves: 'ノードの追加/削除',
    alwaysInDom: '常にDOM内（display: none）',
    effects: 'エフェクト',
    createdDisposed: 'ブランチごとに作成/破棄',
    alwaysActive: '常にアクティブ',
    memoryUsage: 'メモリ',
    lowerWhenHidden: '非表示時は低い',
    constant: '一定',
    transitions: 'トランジション',
    harder: '難しい（ノード再作成）',
    easier: '簡単（CSS）',
    formState: 'フォーム状態',
    lostOnHide: '非表示で失われる',
    preserved: '保持される',
    useCase: 'ユースケース',
    complexConditional: '複雑な条件付きUI',
    simpleToggle: 'シンプルな表示切り替え',
    cleanupPattern: 'クリーンアップパターン',
    effectScheduling: 'エフェクトのスケジューリング',
    effectSchedulingDesc: 'Pulseのエフェクトは同期的にスケジュールされますが、冗長な実行を避けるためにバッチ処理できます。',
    executionModel: '実行モデル',
    circularProtection: '循環依存保護',
    circularProtectionDesc: '自己トリガーするエフェクトは検出され、100回の反復に制限されます：',
    cleanupTiming: 'エフェクトクリーンアップのタイミング',
    nestedEffects: 'ネストしたエフェクト',
    nestedEffectsDesc: 'エフェクトはネストできます。内部エフェクトは外部エフェクトが再実行されると自動的に破棄されます。',
    nextPerformance: '次へ: パフォーマンスガイド →'
  },

  // Performance page
  performance: {
    title: '⚡ パフォーマンス',
    intro: '最高のパフォーマンスのためにPulseアプリケーションを最適化。',
    lazyComputed: '遅延計算値',
    lazyComputedDesc: 'デフォルトでは計算値は即座に評価されます。高コストな計算には遅延評価を使用。',
    whenToUseLazy: '遅延を使用するタイミング',
    listKeying: 'リストキー',
    listKeyingDesc: '適切なキー設定はリストパフォーマンスに不可欠です。',
    goodVsBadKeys: '良いキー vs 悪いキー',
    performanceImpact: 'パフォーマンスへの影響',
    batching: '更新のバッチ処理',
    batchingDesc: '中間の再レンダリングを避けるために複数の状態変更をバッチ処理。',
    automaticBatching: '自動バッチ処理',
    memoization: 'メモ化',
    memoizationDesc: '冗長な作業を避けるために高コストな計算をキャッシュ。',
    lazyRoutes: 'ルートの遅延読み込み',
    lazyRoutesDesc: 'アプリをオンデマンドで読み込まれるチャンクに分割。',
    avoidReactivity: '不要なリアクティビティを避ける',
    avoidReactivityDesc: 'すべてがリアクティブである必要はありません。',
    effectOptimization: 'エフェクトの最適化',
    effectOptimizationDesc: 'エフェクトを高速で焦点を絞ったものに保つ。',
    resourceCaching: 'リソースキャッシング',
    resourceCachingDesc: 'asyncモジュールのキャッシング機能を使用。',
    monitoring: 'パフォーマンス監視',
    monitoringDesc: 'devtoolsモジュールを使用してパフォーマンスを監視。',
    checklist: 'パフォーマンスチェックリスト',
    nextErrorHandling: '次へ: エラー処理'
  },

  // Error Handling page
  errorHandling: {
    title: '🛡️ エラー処理',
    intro: 'Pulseアプリケーション用の堅牢なエラー処理戦略。',
    effectErrors: 'エフェクトエラー',
    asyncErrors: '非同期エラー',
    formErrors: 'フォームエラー',
    routerErrors: 'ルーターエラー',
    boundaries: 'エラー境界',
    logging: 'ログとレポート',
    gracefulDegradation: 'グレースフルデグラデーション',
    summary: 'まとめ',
    nextApiReference: '次へ: APIリファレンス →'
  },

  // HTTP page
  http: {
    title: '🌐 HTTPクライアント',
    intro: 'APIリクエスト用の依存関係なしHTTPクライアント。ネイティブfetchベースでインターセプター、リトライ、タイムアウト、リアクティブ統合をサポート。',
    quickStart: 'クイックスタート',
    quickStartDesc: 'HTTPクライアントをインポートして使用:',
    configuration: '設定',
    configurationDesc: 'すべてのリクエストのデフォルト設定を構成:',
    httpMethods: 'HTTPメソッド',
    responseStructure: 'レスポンス構造',
    interceptors: 'インターセプター',
    interceptorsDesc: 'インターセプターでリクエストとレスポンスをグローバルに変換。',
    requestInterceptors: 'リクエストインターセプター',
    responseInterceptors: 'レスポンスインターセプター',
    manageInterceptors: 'インターセプター管理',
    errorHandling: 'エラー処理',
    errorHandlingDesc: 'すべてのエラーは便利なプロパティを持つHttpErrorにラップ:',
    errorCodes: 'エラーコード',
    description: '説明',
    when: '発生条件',
    errorTimeout: 'タイムアウト',
    errorTimeoutWhen: 'レスポンス前にタイムアウトが満了',
    errorNetwork: 'ネットワークエラー',
    errorNetworkWhen: '接続なしまたはサーバー到達不能',
    errorAbort: 'リクエスト中止',
    errorAbortWhen: 'AbortController.abort()が呼び出された',
    errorHttp: 'HTTPエラー',
    errorHttpWhen: 'レスポンスステータスが2xx範囲外',
    errorParse: 'パースエラー',
    errorParseWhen: 'JSON/blobパースエラー',
    cancellation: 'リクエストキャンセル',
    cancellationDesc: 'AbortControllerでリクエストをキャンセル:',
    retry: 'リトライ設定',
    retryDesc: '失敗したリクエストを自動リトライ:',
    reactiveIntegration: 'リアクティブ統合',
    reactiveIntegrationDesc: 'HTTPリクエストをPulseリアクティビティとシームレスに統合:',
    useHttpResourceDesc: 'SWRパターンでキャッシュされたリソース用:',
    childInstances: '子インスタンス',
    childInstancesDesc: '親から継承する特殊化されたクライアントを作成:',
    fileUpload: 'ファイルアップロード',
    urlParameters: 'URLパラメータ',
    fullExample: '完全な例'
  },

  // Accessibility page
  accessibility: {
    title: '♿ アクセシビリティ',
    intro: 'Pulseはアクセシビリティをコア機能として設計されており、複数のレイヤーでa11yサポートを提供します。',
    nextSecurity: '次へ：セキュリティガイド →'
  },

  // Mobile page
  mobile: {
    title: '📱 モバイル開発',
    intro: 'Pulseでネイティブモバイルアプリを構築。',
    overview: '概要',
    quickStart: 'クイックスタート',
    cliCommands: 'CLIコマンド',
    configuration: '設定',
    configurationDesc: 'pulse.mobile.jsonファイルでモバイルアプリを設定。',
    nativeApis: 'ネイティブAPI',
    requirements: '要件',
    requirementsAndroid: 'Android',
    requirementsIos: 'iOS',
    nextExamples: '次へ: 例 →'
  },

  // Migration from React page
  migrationReact: {
    title: '⚛️ Reactからの移行',
    intro: 'Reactから来ましたか？このガイドは主要な違いを理解し、Pulseへのメンタルモデルの移行を支援します。',
    quickComparison: 'クイック比較',
    quickComparisonDesc: 'ReactとPulseの一目でわかる比較：',
    stateManagement: '状態管理',
    stateManagementDesc: 'ReactはuseStateフックを使用し、Pulseは「パルス」と呼ばれるリアクティブシグナルを使用します。',
    effects: 'エフェクトと副作用',
    effectsDesc: '両フレームワークはエフェクトを使用しますが、Pulseは依存関係を自動追跡します。',
    computed: '計算値',
    computedDesc: 'ReactのuseMemoは、自動依存関係追跡付きのPulseのcomputed()になります。',
    components: 'コンポーネント',
    componentsDesc: 'ReactはJSXコンポーネントを使用し、PulseはDOM要素を返すプレーンなJavaScript関数を使用します。',
    conditionalRendering: '条件付きレンダリング',
    conditionalRenderingDesc: 'Reactは三項演算子と&&を使用し、Pulseはwhen()ヘルパーを提供します。',
    lists: 'リストレンダリング',
    listsDesc: 'Reactはmap()を使用し、Pulseは自動キーイング付きのlist()を提供します。',
    forms: 'フォーム処理',
    formsDesc: 'PulseはuseForm()による組み込みフォームバリデーションを提供します。',
    globalState: 'グローバル状態',
    globalStateDesc: 'ReactはContext + useContextを使用し、Pulseは組み込み永続化付きのcreateStore()を使用します。',
    routing: 'ルーティング',
    routingDesc: '両方とも似たルーティングAPIを持っていますが、Pulseのものは追加の依存関係なしで組み込まれています。',
    cheatSheet: 'チートシート',
    cheatSheetDesc: '一般的なパターンのクイックリファレンス：',
    notes: 'メモ',
    cheatState: 'リアクティブ状態を作成',
    cheatSet: '状態を直接設定',
    cheatUpdate: '関数的更新',
    cheatEffect: '依存関係を自動追跡',
    cheatComputed: 'メモ化された派生値',
    cheatElement: 'CSSセレクター構文',
    cheatList: 'キー関数付き',
    cheatWhen: '条件付きレンダリング',
    cheatContext: 'グローバルストアアクセス',
    cheatRef: '直接DOM参照',
    stepByStep: 'ステップバイステップ移行',
    stepByStepDesc: 'ReactアプリをPulseに移行するには以下の手順に従ってください：',
    step1Title: 'Pulseをインストール',
    step1Desc: 'Reactと一緒にPulseをプロジェクトに追加します。',
    step2Title: 'リーフコンポーネントから開始',
    step2Desc: '小さな自己完結型コンポーネントから移行を始めます。これらは変換とテストが容易です。',
    step3Title: '状態管理を変換',
    step3Desc: 'useStateをpulse()に、useEffectをeffect()に置き換えます。覚えておいてください：依存関係配列は不要です！',
    step4Title: '親コンポーネントを移行',
    step4Desc: '子コンポーネントが変換されたら、親コンポーネントに向かって作業を進めます。',
    step5Title: 'Reactを削除',
    step5Desc: 'すべてのコンポーネントが移行されたら、Reactの依存関係を削除して、より小さなバンドルをお楽しみください！',
    gotchas: 'よくある落とし穴',
    gotcha1Title: '更新にget()を使用しない',
    gotcha1Desc: '競合状態を避けるために、関数的更新にはupdate()を使用してください。',
    gotcha2Title: 'エフェクト内ではpeek()ではなくget()を使用',
    gotcha2Desc: 'peek()は追跡なしで読み取ります - 依存関係を作成するにはget()を使用してください。',
    gotcha3Title: '配列/オブジェクトを変更しない',
    gotcha3Desc: 'コレクションを更新する際は常に新しい参照を作成してください。',
    needHelp: '助けが必要ですか？',
    needHelpDesc: '移行について質問がありますか？お手伝いします！',
    discussions: 'GitHub Discussions',
    issues: '問題を報告',
    getStarted: 'Pulseを始める',
    viewExamples: 'サンプルを見る',
    tip: 'ヒント',
    stateTip: 'useStateとは異なり、pulse()はget()、set()、update()メソッドを持つ単一のオブジェクトを返します。',
    effectTip: '依存関係配列は不要！Pulseはエフェクト内で読み取られるパルスを自動追跡します。',
    storeTip: 'Pulseストアはよりシンプル - プロバイダー不要、どこでもインポートして使用できます。'
  },

  // Migration from Angular page
  migrationAngular: {
    title: '🅰️ Angularからの移行',
    intro: 'Angularから来ましたか？このガイドでは、主要な違いを理解し、Pulseへの思考モデルの移行を支援します。',
    quickComparison: 'クイック比較',
    quickComparisonDesc: 'AngularとPulseを一目で比較:',
    componentStructure: 'コンポーネント構造',
    componentStructureDesc: 'Angularはテンプレート付きのデコレートされたクラスを使用し、Pulseはプレーンなjavascript関数を使用します。',
    propertyBinding: 'プロパティとイベントバインディング',
    propertyBindingDesc: 'Angularはバインディングに特殊な構文を使用し、PulseはリアクティブヘルパーでDOMを直接操作します。',
    observables: 'Observables vs Pulses',
    observablesDesc: 'AngularはRxJS Observablesに依存しています。Pulseは自動依存関係追跡を備えたシンプルなリアクティブシグナルを使用します。',
    dependencyInjection: '依存性注入',
    dependencyInjectionDesc: 'Angularは複雑なDIシステムを使用します。PulseはシンプルなESモジュールインポートを使用します。',
    directives: 'ディレクティブ',
    directivesDesc: 'Angularの構造ディレクティブ（*ngIf、*ngFor）はPulseヘルパー（when、list）になります。',
    forms: 'フォーム処理',
    formsDesc: 'AngularにはReactive FormsとTemplate-driven formsがあります。Pulseは組み込みバリデーション付きのuseForm()を提供します。',
    routing: 'ルーティング',
    routingDesc: '両方とも似たルーティング概念を持っていますが、Pulseのルーターはよりシンプルで組み込みです。',
    http: 'HTTPクライアント',
    httpDesc: 'Angular HttpClientはobservablesを使用します。Pulse HTTPはオプションのリアクティブラッパー付きのpromiseを使用します。',
    pipes: 'Pipes vs Computed',
    pipesDesc: 'データ変換用のAngular pipesはPulseのcomputed値になります。',
    cheatSheet: 'チートシート',
    cheatSheetDesc: '一般的なパターンのクイックリファレンス:',
    notes: 'メモ',
    cheatComponent: 'デコレーター不要',
    cheatSignal: 'よりシンプルなリアクティブプリミティブ',
    cheatEmit: '直接値更新',
    cheatSubscribe: '自動追跡、自動クリーンアップ',
    cheatDerived: 'オペレーター不要',
    cheatIf: '条件付きレンダリング',
    cheatFor: '自動キーイング付きリスト',
    cheatModel: '双方向バインディング',
    cheatBind: 'リアクティブクラスバインディング',
    cheatService: 'ストアをエクスポートするだけ',
    cheatAsync: '自動サブスクリプション',
    stepByStep: 'ステップバイステップ移行',
    stepByStepDesc: 'AngularアプリをPulseに移行する手順:',
    step1Title: 'Pulseをインストール',
    step1Desc: 'プロジェクトにPulseを追加します。移行中はAngularと並行して実行できます。',
    step2Title: 'リーフコンポーネントから始める',
    step2Desc: 'Angularサービスに依存しない小さな自己完結型コンポーネントから始めます。',
    step3Title: 'サービスをストアに置き換え',
    step3Desc: 'AngularサービスをPulseストアに変換します。BehaviorSubjectをpulse()に、observablesをeffectsに置き換えます。',
    step4Title: 'テンプレートを移行',
    step4Desc: 'AngularテンプレートをPulseのel()関数に変換します。*ngIfをwhen()に、*ngForをlist()に置き換えます。',
    step5Title: 'Angularを削除',
    step5Desc: 'すべてのコンポーネントが移行されたら、Angular依存関係を削除します。95%以上小さいバンドルをお楽しみください！',
    gotchas: 'よくある落とし穴',
    gotcha1Title: '手動Unsubscribe不要',
    gotcha1Desc: 'RxJSとは異なり、Pulseエフェクトは自動クリーンアップします。takeUntilやunsubscribeパターンは不要です。',
    gotcha2Title: '依存性注入なし',
    gotcha2Desc: 'ESインポートを使用するだけです。プロバイダー、モジュール、デコレーターは不要です。',
    gotcha3Title: '変更検出なし',
    gotcha3Desc: 'OnPush、markForCheck、detectChangesは忘れてください。Pulse更新は自動的で正確です。',
    gotcha4Title: 'RxJSオペレーター不要',
    gotcha4Desc: '複雑なオペレーターチェーンをcomputed()とasync/awaitに置き換えます。はるかにシンプルです！',
    needHelp: 'ヘルプが必要ですか？',
    needHelpDesc: '移行について質問がありますか？お手伝いします！',
    discussions: 'GitHub Discussions',
    issues: '問題を報告',
    getStarted: 'Pulseを始める',
    viewExamples: 'サンプルを見る',
    tip: 'ヒント',
    componentTip: 'デコレーター、モジュール、ボイラープレートなし。DOM要素を返す関数だけです。',
    observablesTip: 'subscribe/unsubscribe不要！エフェクトは自動的に依存関係を追跡しクリーンアップします。',
    diTip: 'プロバイダーやモジュールは不要です。必要なものを必要な場所でインポートするだけです。'
  },

  // Migration from Vue page
  migrationVue: {
    title: '💚 Vueからの移行',
    intro: 'Vueから来ましたか？このガイドでは、主な違いを理解し、Pulseに思考を適応させる方法を説明します。',
    quickComparison: 'クイック比較',
    quickComparisonDesc: 'VueとPulseの比較を一目で確認：',
    reactivity: 'リアクティビティ: ref vs pulse',
    reactivityDesc: 'Vueはリアクティビティにref()とreactive()を使用します。Pulseはすべてのリアクティブな状態に単一のpulse()プリミティブを使用します。',
    componentStructure: 'コンポーネント構造',
    componentStructureDesc: 'VueはSingle File Components (SFC)をtemplate、script、styleと共に使用します。Pulseはシンプルなjavascript関数を使用します。',
    watchers: 'Watchers vs Effects',
    watchersDesc: 'Vueにはwatch()とwatchEffect()があります。Pulseはこれをeffect()だけに簡素化し、自動的な依存関係追跡を行います。',
    directives: 'テンプレートディレクティブ',
    directivesDesc: 'Vueのv-if、v-for、v-modelディレクティブはPulseヘルパーになります: when()、list()、model()。',
    propsEvents: 'Props & Events',
    propsEventsDesc: 'VueはdefineProps()とdefineEmits()を使用します。Pulseはすべてを関数の引数として渡します。',
    provideInject: 'Provide/Inject vs Stores',
    provideInjectDesc: 'Vueのprovide/injectとPiniaストアは、PulseではシンプルなESモジュールエクスポートになります。',
    lifecycle: 'ライフサイクルフック',
    lifecycleDesc: 'Vueには多くのライフサイクルフックがあります。Pulseはeffectのクリーンアップ関数で簡素化します。',
    slots: 'スロット',
    slotsDesc: 'VueのスロットはPulseではchildren propsまたはレンダー関数になります。',
    routing: 'ルーティング',
    routingDesc: '両方とも似たようなルーティング概念を持っています。Pulseのルーターは追加の依存関係なしで組み込まれています。',
    forms: 'フォーム処理',
    formsDesc: 'Vueはフォームにv-modelを使用します。PulseはuseForm()と組み込みのバリデーションを提供します。',
    cheatSheet: 'チートシート',
    cheatSheetDesc: '一般的なパターンのクイックリファレンス：',
    notes: 'メモ',
    cheatRef: 'リアクティブな状態を作成',
    cheatRead: '値を読み取る',
    cheatWrite: '値を書き込む',
    cheatReactive: 'オブジェクトも同じAPI',
    cheatComputed: '同じ概念！',
    cheatWatch: '統一されたシンプルなAPI',
    cheatIf: '条件付きレンダリング',
    cheatFor: 'キー関数付きリスト',
    cheatModel: '双方向バインディング',
    cheatEvent: 'イベント処理',
    cheatBind: 'リアクティブな属性',
    cheatProvide: 'モジュールをエクスポートするだけ',
    stepByStep: 'ステップバイステップの移行',
    stepByStepDesc: 'VueアプリをPulseに移行するには、これらの手順に従ってください：',
    step1Title: 'Pulseをインストール',
    step1Desc: 'Vueと一緒にプロジェクトにPulseを追加します。',
    step2Title: 'リーフコンポーネントから開始',
    step2Desc: '小さな自己完結型のコンポーネントから移行を開始します。変換とテストが簡単です。',
    step3Title: '状態をPulsesに変換',
    step3Desc: 'ref()をpulse()に、reactive()をpulse()に置き換えます。watch/watchEffectをeffect()に置き換えます。',
    step4Title: 'テンプレートを移行',
    step4Desc: 'VueテンプレートをPulseのel()関数に変換します。v-ifをwhen()に、v-forをlist()に置き換えます。',
    step5Title: 'Vueを削除',
    step5Desc: 'すべてのコンポーネントが移行されたら、Vueの依存関係を削除し、88%小さくなったバンドルを楽しみましょう！',
    gotchas: 'よくある落とし穴',
    gotcha1Title: '.valueプロパティなし',
    gotcha1Desc: 'Pulseは Vueの.valueプロパティの代わりにget()/set()メソッドを使用します。',
    gotcha2Title: '直接変更なし',
    gotcha2Desc: 'Vueのreactive()と異なり、Pulseはオブジェクトと配列に新しい参照を作成する必要があります。',
    gotcha3Title: 'Effectのクリーンアップが異なる',
    gotcha3Desc: 'onUnmounted()を使用する代わりに、effect()からクリーンアップ関数を返します。',
    gotcha4Title: 'テンプレート構文なし',
    gotcha4Desc: 'PulseはHTMLテンプレートの代わりにel()でCSSセレクター構文を使用します。',
    needHelp: 'ヘルプが必要ですか？',
    needHelpDesc: '移行について質問がありますか？お手伝いします！',
    discussions: 'GitHub Discussions',
    issues: '問題を報告',
    getStarted: 'Pulseを始める',
    viewExamples: 'サンプルを見る',
    tip: 'ヒント',
    reactivityTip: 'Vueのref/reactiveの分割と異なり、Pulseはすべての値に単一のpulse()を使用します。どちらを使うか決める必要はもうありません！',
    componentTip: 'SFCコンパイラは不要です。コンポーネントはDOM要素を返す関数に過ぎません。',
    watchersTip: '1つのeffect()がwatch()、watchEffect()、computed()の副作用を置き換えます。依存関係は常に自動です。',
    propsEventsTip: 'コールバックをpropsとして直接渡します。emit()のセレモニーは不要です。',
    provideInjectTip: 'provide/injectのボイラープレートなし。pulseをエクスポートしてどこでもインポートするだけです。',
    lifecycleTip: 'effect()からクリーンアップ関数を返してアンマウントロジックを処理します。複数のライフサイクルフックよりはるかにシンプルです！'
  },

  // Testing page
  testing: {
    title: '🧪 テスト',
    intro: 'Node.js組み込みテストランナーとPulseテストユーティリティを使用したPulseアプリケーションのテストに関する包括的なガイド。',
    quickStart: 'クイックスタート',
    quickStartDesc: 'Pulseは追加の依存関係なしでNode.js組み込みテストランナーを使用します。',
    runningTests: 'テストの実行',
    writingTests: 'テストの作成',
    writingTestsDesc: 'テストはNode.jsテストモジュールまたはPulseのカスタムテストユーティリティを使用して作成できます。',
    basicStructure: '基本的なテスト構造',
    pulseTestUtils: 'Pulseテストユーティリティ',
    pulseTestUtilsDesc: 'Pulseはアサーション、スパイ、非同期サポートを備えた軽量テストランナーを提供します。',
    isolatedContexts: '分離されたリアクティブコンテキスト',
    isolatedContextsDesc: 'createContext()とwithContext()を使用して、テスト間でリアクティブ状態を分離します。',
    testingReactivity: 'リアクティビティのテスト',
    testingReactivityDesc: 'パルス、計算値、エフェクトをテストするためのパターン。',
    testingPulses: 'Pulsesのテスト',
    testingComputed: '計算値のテスト',
    testingEffects: 'エフェクトのテスト',
    testingDom: 'DOMコンポーネントのテスト',
    testingDomDesc: 'モックDOMユーティリティを使用してブラウザなしでDOMレンダリングをテストします。',
    mockDomSetup: 'モックDOMセットアップ',
    testingElements: '要素のテスト',
    testingLists: 'リストのテスト',
    testingConditionals: '条件分岐のテスト',
    mockDomAdapter: 'テスト用MockDOMAdapter',
    mockDomAdapterDesc: 'MockDOMAdapterはブラウザなしでテストするための完全なDOM抽象化を提供します。',
    testingAsync: '非同期操作のテスト',
    testingAsyncDesc: 'useAsyncとuseResourceを使用した非同期データ取得をテストするパターン。',
    testingForms: 'フォームのテスト',
    testingFormsDesc: 'フォームバリデーション、フィールド状態、送信をテストします。',
    testingStore: 'Storesのテスト',
    testingStoreDesc: 'createStore、actions、gettersを使用したグローバル状態管理をテストします。',
    testingRouter: 'Routerのテスト',
    testingRouterDesc: 'モックHistory APIを使用してルートマッチング、ナビゲーション、ガードをテストします。',
    testingHttp: 'HTTPリクエストのテスト',
    testingHttpDesc: 'HTTPクライアントの動作をテストするためにfetch APIをモックします。',
    testHelpers: 'テストヘルパーリファレンス',
    testHelpersDesc: 'すべてのテストユーティリティとアサーションの完全なリファレンス。',
    assertions: 'アサーション',
    assertionsCaption: '利用可能なアサーション関数',
    function: '関数',
    description: '説明',
    example: '例',
    assertDesc: '条件が真であることをアサート',
    assertEqualDesc: '厳密な等価性をアサート (===)',
    assertDeepEqualDesc: '深い等価性をアサート (JSON比較)',
    assertThrowsDesc: '関数がエラーをスローすることをアサート',
    assertThrowsAsyncDesc: '非同期関数がエラーをスローすることをアサート',
    assertTruthyDesc: '値がtruthyであることをアサート',
    assertFalsyDesc: '値がfalsyであることをアサート',
    assertInstanceOfDesc: 'instanceofチェックをアサート',
    assertTypeDesc: 'typeofチェックをアサート',
    spiesAndMocks: 'スパイとタイミングユーティリティ',
    coverageReporting: 'カバレッジレポート',
    coverageReportingDesc: 'テストされていないコードを特定するためのコードカバレッジレポートを生成します。',
    coverageTips: 'カバレッジのヒント',
    coverageTip1: 'ビジネスロジックとユーティリティの高いカバレッジを目指す',
    coverageTip2: '100%カバレッジを追求しない - 意味のあるテストに焦点を当てる',
    coverageTip3: 'エッジケースとエラー条件をテストする',
    coverageTip4: 'カバレッジを使用してデッドコードを特定する',
    bestPractices: 'ベストプラクティス',
    practice1Title: '1. テスト状態を分離する',
    practice1Desc: '分離されたリアクティブコンテキストを使用して、テスト間の状態漏れを防ぎます。',
    practice2Title: '2. 実装ではなく動作をテストする',
    practice2Desc: 'コードが何をするかに焦点を当て、内部的にどのように行うかではない。',
    practice3Title: '3. 説明的なテスト名を使用する',
    practice3Desc: 'テスト名は期待される動作を明確に説明する必要があります。',
    practice4Title: '4. AAAパターンに従う',
    practice4Desc: '明確さのためにArrange、Act、Assertセクションでテストを構造化します。',
    ciIntegration: 'CI/CD統合',
    ciIntegrationDesc: 'CI/CDパイプラインでテストを自動的に実行します。',
    nextDebugging: '次へ: デバッグ →'
  },

  // Changelog page
  changelog: {
    title: '📋 変更履歴',
    intro: 'Pulse Frameworkの最近の更新と改善。',
    version: 'バージョン',
    releaseDate: 'リリース日',
    changes: '変更点',
    added: '追加',
    changed: '変更',
    fixed: '修正',
    removed: '削除',
    deprecated: '非推奨',
    security: 'セキュリティ',
    breaking: '破壊的変更',
    features: '機能',
    bugFixes: 'バグ修正',
    improvements: '改善',
    documentation: 'ドキュメント',
    performance: 'パフォーマンス',
    tests: 'テスト'
  },

  // Benchmarks page
  benchmarks: {
    title: '📊 ベンチマーク',
    intro: 'ブラウザで直接実行されるインタラクティブなパフォーマンステスト。「すべて実行」をクリックして、お使いのマシンでPulseのパフォーマンスを測定してください。',
    runAll: 'すべて実行',
    clear: '結果をクリア',
    running: '実行中',
    clickToRun: '「実行」をクリックしてテスト',
    note: '注意',
    noteText: '結果はブラウザ、ハードウェア、システム負荷によって異なります。正確な測定のために複数回実行してください。',

    // Categories
    reactivity: 'リアクティビティ',
    computed: '計算値',
    effects: 'エフェクト',
    batching: 'バッチ処理',
    dom: 'DOM操作',
    advanced: '高度なパターン',

    // Comparison table
    comparison: 'フレームワーク比較',
    comparisonIntro: 'Pulseは他のフレームワークとどう比較されますか？上記のベンチマークを実行して実際の結果を確認してください。',
    metric: '指標',
    bundleSize: 'バンドルサイズ (gzip)',
    signalCreate: 'シグナル作成',
    signalUpdate: 'シグナル更新',
    dependencies: '依存関係',
    buildRequired: 'ビルド必須',

    // Methodology
    methodology: '方法論',
    howItWorks: 'ベンチマークの仕組み',
    warmup: 'ウォームアップ',
    warmupText: 'JITコンパイルをウォームアップするために、まず10%の反復が実行されます。',
    measurement: '測定',
    measurementText: '操作はperformance.now()タイミングでタイトループで実行されます。',
    precision: '精度',
    precisionText: '結果はops/sec、平均時間、合計時間を表示します。',
    factors: '結果に影響する要因',
    factor1: 'ブラウザエンジン（ChromeのV8、FirefoxのSpiderMonkey、SafariのJSC）',
    factor2: 'システム負荷と利用可能なメモリ',
    factor3: 'CPU周波数スケーリングとサーマルスロットリング',
    factor4: 'ブラウザ拡張機能とDevToolsの状態',

    // Navigation
    nextPerformance: '次へ：パフォーマンスガイド →'
  },

  // WebSocket page
  websocket: {
    title: '🔌 WebSocketクライアント',
    intro: '自動再接続、ハートビート、メッセージキューイング、リアクティブ統合を備えたWebSocketクライアント。',
    quickStart: 'クイックスタート',
    quickStartDesc: 'シンプルなWebSocket接続にはリアクティブフックを使用:',
    lowLevelApi: '低レベルAPI',
    creatingWebSocket: 'WebSocketの作成',
    reactiveState: 'リアクティブ状態',
    reactiveStateDesc: 'すべての状態はPulsesとして公開されます:',
    sendingMessages: 'メッセージの送信',
    eventListeners: 'イベントリスナー',
    interceptors: 'メッセージインターセプター',
    interceptorsDesc: '受信・送信メッセージを変換:',
    control: '制御',
    reactiveHook: 'リアクティブフック（推奨）',
    reactiveHookDesc: 'ほとんどのユースケースでは、useWebSocketフックがシンプルなAPIを提供します:',
    usageWithEffects: 'エフェクトとの使用',
    errorHandling: 'エラーハンドリング',
    errorHandlingDesc: 'すべてのエラーは便利なプロパティを持つWebSocketErrorでラップされます:',
    errorCodes: 'エラーコード',
    description: '説明',
    when: '発生条件',
    errorConnectFailed: '接続失敗',
    errorConnectFailedWhen: '接続を確立できない',
    errorClose: '接続クローズ',
    errorCloseWhen: 'サーバーまたはクライアントが接続を閉じた',
    errorTimeout: '接続タイムアウト',
    errorTimeoutWhen: '接続試行がタイムアウト',
    errorSendFailed: '送信失敗',
    errorSendFailedWhen: 'メッセージを送信できなかった',
    patterns: '一般的なパターン',
    chatApplication: 'チャットアプリケーション',
    realTimeUpdates: 'リアルタイム更新',
    reconnectionWithAuth: '認証付き再接続'
  },

  // GraphQL page
  graphql: {
    title: '🔮 GraphQLクライアント',
    intro: 'クエリキャッシング、ミューテーション、サブスクリプション、リアクティブ統合を備えたGraphQLクライアント。',
    quickStart: 'クイックスタート',
    quickStartDesc: 'クライアントを作成し、クエリにフックを使用:',
    creatingClient: 'クライアントの作成',
    queries: 'クエリ',
    usingQueryData: 'クエリデータの使用',
    mutations: 'ミューテーション',
    optimisticUpdates: '楽観的更新',
    optimisticUpdatesDesc: 'サーバーがミューテーションを処理している間にUIを即座に更新:',
    subscriptions: 'サブスクリプション',
    reactiveVariables: 'リアクティブ変数',
    errorHandling: 'エラーハンドリング',
    errorHandlingDesc: 'すべてのエラーは便利なプロパティを持つGraphQLErrorでラップされます:',
    errorCodes: 'エラーコード',
    description: '説明',
    errorGraphql: 'レスポンス内のGraphQLエラー',
    errorNetwork: 'ネットワークまたは接続エラー',
    errorTimeout: 'リクエストタイムアウト',
    errorParse: 'レスポンスの解析失敗',
    interceptors: 'インターセプター',
    cacheManagement: 'キャッシュ管理',
    patterns: '一般的なパターン',
    pagination: 'ページネーション',
    dependentQueries: '依存クエリ',
    realTimeChat: 'リアルタイムチャット'
  },

  // Context page
  context: {
    title: '🎯 Context API',
    intro: '依存性注入とprop drilling回避のためのContext API。React Contextに似ています。',
    quickStart: 'クイックスタート',
    quickStartDesc: 'コンテキストを作成し、子に値を提供:',
    creatingContexts: 'コンテキストの作成',
    providingValues: '値の提供',
    basicProvider: '基本的なProvider',
    reactiveValues: 'リアクティブ値の提供',
    reactiveValuesDesc: 'pulseを渡してコンテキスト値をリアクティブに:',
    shorthandSyntax: '省略構文',
    nestedProviders: 'ネストされたProvider',
    nestedProvidersDesc: '内側のproviderが外側を上書きします:',
    consumingContext: 'コンテキストの消費',
    consumerComponent: 'Consumerコンポーネント',
    multipleContexts: '複数のコンテキスト',
    provideManyDesc: '一度に複数のコンテキストを提供:',
    useContextSelectorDesc: '複数のコンテキストから派生:',
    utilities: 'コンテキストユーティリティ',
    patterns: '一般的なパターン',
    themeProvider: 'テーマProvider',
    authContext: '認証コンテキスト',
    localizationContext: 'ローカライゼーションコンテキスト',
    compoundComponents: '複合コンポーネント',
    testing: 'コンテキストを使用したテスト'
  },

  // DevTools page
  devtools: {
    title: '🛠️ DevTools',
    intro: '開発用のデバッグ、プロファイリング、アクセシビリティ監査機能。',
    enabling: 'DevToolsの有効化',
    enablingDesc: 'DevToolsを有効にしてデバッグ機能にアクセス:',
    trackedPulses: '追跡されたPulsesとエフェクト',
    trackedPulsesDesc: 'デバッグ用にpulsesとエフェクトを追跡:',
    diagnostics: '診断',
    getDiagnosticsDesc: 'ランタイム統計を取得:',
    getEffectStatsDesc: 'エフェクトごとの統計を取得:',
    getPulseListDesc: 'すべての追跡されたpulsesを取得:',
    dependencyGraph: '依存関係グラフ',
    dependencyGraphDesc: 'リアクティブ依存関係を視覚化:',
    timeTravel: 'タイムトラベルデバッグ',
    timeTravelDesc: '状態履歴をナビゲート:',
    profiling: 'パフォーマンスプロファイリング',
    profileDesc: 'コードブロックをプロファイル:',
    markDesc: 'タイミングポイントをマーク:',
    a11yAudit: 'アクセシビリティ監査',
    a11yAuditDesc: 'a11y問題を見つけるための組み込みアクセシビリティ監査:',
    oneTimeAudit: '一回限りの監査',
    continuousAuditing: '継続的監査',
    a11yStats: 'A11y統計',
    visualHighlighting: 'ビジュアルハイライト',
    exportReports: 'レポートのエクスポート',
    browserConsole: 'ブラウザコンソール',
    browserConsoleDesc: '有効にすると、DevToolsはwindow.__PULSE_DEVTOOLS__を公開します:',
    bestPractices: 'ベストプラクティス',
    developmentOnly: '開発時のみ',
    namingConventions: '命名規則',
    performanceMonitoring: 'パフォーマンス監視',
    a11yInDevelopment: '開発中のA11y'
  },

  // SSR page
  ssr: {
    title: '🖥️ サーバーサイドレンダリング',
    intro: 'SEOの改善、初期ページロードの高速化、低速デバイスでのパフォーマンス向上のために、Pulseアプリケーションをサーバーでレンダリングします。',
    quickStart: 'クイックスタート',
    quickStartDesc: 'SSRユーティリティをインポートして使用:',
    serverSetup: 'サーバーセットアップ',
    serverSetupDesc: 'SSR付きExpressサーバーをセットアップ:',
    clientHydration: 'クライアントサイドハイドレーション',
    clientHydrationDesc: 'イベントリスナーをアタッチし、インタラクティブ性を有効にするために、クライアントでサーバーレンダリングされたHTMLをハイドレーション:',
    stateSerialization: '状態シリアライゼーション',
    stateSerializationDesc: 'サーバーとクライアント間で転送するために状態をシリアライズ・デシリアライズ:',
    modeDetection: 'SSRモード検出',
    modeDetectionDesc: 'コードがサーバーとクライアントのどちらで実行されているかを検出:',
    ssrSafeEffects: 'SSRセーフなエフェクト',
    ssrSafeEffectsDesc: 'SSRとブラウザ両方の環境で正しく動作するエフェクトを記述:',
    asyncData: 'SSRでの非同期データ',
    asyncDataDesc: 'useAsyncはデータフェッチのためにSSRと自動的に統合されます:',
    architecture: 'SSRアーキテクチャ',
    architectureDesc: 'SSRシステムはいくつかの専門モジュールで構成されています:',
    module: 'モジュール',
    purpose: '目的',
    moduleMain: 'メインエントリポイント（renderToString、hydrate）',
    moduleSerializer: 'MockNodeツリーのHTMLシリアライゼーション',
    moduleHydrator: 'クライアントサイドハイドレーションユーティリティ',
    moduleAsync: 'SSR中の非同期データ収集',
    howItWorks: 'SSRの仕組み',
    howItWorksDesc: 'SSRプロセスの理解:',
    step1Title: 'サーバーレンダリング:',
    step1Desc: 'renderToString()がMockDOMAdapterを使用して分離されたコンテキストを作成します。',
    step2Title: '非同期収集:',
    step2Desc: '最初のレンダリングですべてのuseAsync操作を収集します。',
    step3Title: 'データフェッチ:',
    step3Desc: 'すべての非同期操作が完了するのを待機します（タイムアウト付き）。',
    step4Title: '再レンダリング:',
    step4Desc: '解決されたデータで2回目のレンダリング。',
    step5Title: 'シリアライゼーション:',
    step5Desc: 'MockNodeツリーがHTML文字列に変換されます。',
    step6Title: '状態転送:',
    step6Desc: '状態がクライアント用にシリアライズされます。',
    step7Title: 'ハイドレーション:',
    step7Desc: 'クライアントが既存のDOMにイベントリスナーをアタッチします。',
    apiReference: 'APIリファレンス',
    renderToStringDesc: '非同期データを待機しながら、コンポーネントを非同期でHTML文字列にレンダリング:',
    renderToStringSyncDesc: 'コンポーネントを同期でHTML文字列にレンダリング（非同期待機なし）:',
    hydrateDesc: 'サーバーレンダリングされたHTMLにイベントリスナーをアタッチ:',
    serializeDesc: '状態を安全にシリアライズ・デシリアライズ:',
    fullExample: '完全な例',
    fullExampleDesc: 'サーバー、クライアント、共有コンポーネントを含む完全なSSRセットアップ:',
    sharedComponent: '共有コンポーネント（App.js）',
    serverFile: 'サーバー（server.js）',
    clientFile: 'クライアント（client.js）',
    bestPractices: 'ベストプラクティス',
    practice1Title: 'isSSR()ガードを使用:',
    practice1Desc: 'ブラウザ専用API（window、document、localStorage）をisSSR()チェックでラップします。',
    practice2Title: '適切なタイムアウトを設定:',
    practice2Desc: 'APIのレスポンス時間に基づいてタイムアウトを設定します。',
    practice3Title: 'エラーを適切に処理:',
    practice3Desc: 'SSRが失敗した場合のフォールバックUIを提供します。',
    practice4Title: 'クライアント・サーバー間の差異を最小化:',
    practice4Desc: 'サーバーとクライアントの両方で同じコンポーネントツリーがレンダリングされることを確認します。',
    practice5Title: '必要な状態のみをシリアライズ:',
    practice5Desc: '初期状態で大きなデータや機密データを転送しないようにします。',
    troubleshooting: 'トラブルシューティング',
    hydrationMismatch: 'ハイドレーション不一致',
    hydrationMismatchDesc: 'サーバーとクライアントは同一のHTMLをレンダリングする必要があります。時間依存値やランダム値を避けてください:',
    browserApis: 'サーバーでのブラウザAPI',
    browserApisDesc: 'Window、document、その他のブラウザAPIはSSR中は利用できません:',
    asyncTimeout: '非同期タイムアウト',
    asyncTimeoutDesc: '非同期操作に時間がかかりすぎる場合は、タイムアウトを増やしてください:',
    prevHttp: '← HTTPクライアント',
    nextGraphQL: 'GraphQLクライアント →'
  }
};
