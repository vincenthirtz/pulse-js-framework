# Milestone v1.8.2 — Router & Navigation Enhancements

**Status:** Planned
**Target:** runtime/router.js (single file, additive changes)
**Breaking changes:** None — all features are additive

---

## Architecture Decision Record (ADR)

### ADR-009: Router & Navigation Enhancements v1.8.2

**Context:** The Pulse router provides core SPA routing but lacks several features
expected by modern SPAs: typed query params, route groups, transitions,
loading indicators, and navigation convenience helpers.

**Decision:** Implement all 6 enhancements directly in `runtime/router.js` as
additive features. No new files needed. All new state uses `pulse()` for reactivity.
All new APIs follow existing conventions (return disposers, options-as-last-param).

**Consequences:**
- Router file grows ~300-400 lines (acceptable, stays under 1600 LOC)
- No new dependencies (zero-dep policy maintained)
- All features are opt-in (no behavior changes for existing users)
- New exports added to `package.json` exports map: none needed (same module)

---

## Implementation Order & Dependencies

```
#73 back/forward helpers ─── (no deps, simplest, already partially done)
         │
#70 query param handling ─── (no deps, standalone utility improvement)
         │
#68 aliases & redirects ──── (no deps, extends existing redirect support)
         │
#72 loading state ─────────── (no deps, extends existing isLoading pulse)
         │
#71 route groups ──────────── (depends on route compilation logic from #68)
         │
#66 transitions & lifecycle ─ (depends on #72 for loading awareness)
```

**Implementation order:** #73 → #70 → #68 → #72 → #71 → #66

---

## Issue #73 — `router.back()` / `router.forward()` helpers

**Status:** Already implemented (back/forward/go exist at lines 1108-1133)

The current implementation wraps `window.history.back()`, `forward()`, and `go(delta)`.
These are already exposed on the router instance.

**Enhancement needed:** Integrate with scroll restoration by saving scroll position
before back/forward, and return a Promise that resolves after the popstate fires.

### API Design

```javascript
// Current (keep as-is)
router.back();
router.forward();
router.go(-2);

// Enhancement: return Promise, save scroll
await router.back();   // Saves scroll, then history.back()
await router.forward(); // Saves scroll, then history.forward()
await router.go(-2);    // Saves scroll, then history.go(-2)
```

### Implementation

1. Save current scroll position before calling `history.back/forward/go`
2. Return a Promise that resolves on the next `popstate` event (with timeout fallback)
3. Call `persistScrollPositions()` if persistence is enabled

---

## Issue #70 — Improved Query Parameter Handling

**Current behavior:** `parseQuery()` returns all values as strings. `navigate()` uses
`new URLSearchParams(query).toString()` which doesn't handle arrays or typed values.

### API Design

```javascript
// Auto-encode special characters (already works via URLSearchParams)
router.navigate('/search', { query: { q: 'hello world' } });
// URL: /search?q=hello+world

// Array query params
router.navigate('/filter', { query: { tags: ['a', 'b'] } });
// URL: /filter?tags=a&tags=b
// Parsed: { tags: ['a', 'b'] }

// Typed parsing (opt-in via router config)
const router = createRouter({
  routes,
  parseQueryTypes: true  // Enable typed parsing
});
// ?count=42&active=true&name=John
// → { count: 42, active: true, name: 'John' }
```

### Implementation

1. **`buildQueryString(query)`** — New internal helper:
   - Handle array values: `{ tags: ['a', 'b'] }` → `tags=a&tags=b`
   - Handle null/undefined: skip those keys
   - Encode special characters (URLSearchParams handles this)

2. **`parseQuery()` enhancement** — Add typed parsing:
   - Detect numbers: `'42'` → `42` (only if `parseQueryTypes` enabled)
   - Detect booleans: `'true'`/`'false'` → `true`/`false`
   - Always handle arrays: multiple same-key → array (already works)

3. **Update `navigate()`** to use `buildQueryString()` instead of raw URLSearchParams

---

## Issue #68 — Route Aliases and Redirects

**Current behavior:** Redirects already work via `{ redirect: '/new' }` in route config.
Aliases are not supported.

### API Design

```javascript
const router = createRouter({
  routes: {
    '/new-path': () => NewPage(),

    // Redirect: navigates to new URL (URL changes)
    '/old-path': { redirect: '/new-path' },

    // Alias: serves same content without URL change
    '/alias': { alias: '/actual' },

    // Dynamic redirect (already supported)
    '/user/:id': { redirect: ({ params }) => `/profile/${params.id}` },
  }
});
```

### Implementation

1. **Alias support in `normalizeRoute()`:**
   - Add `alias` field to route config
   - During route compilation, register alias as a separate trie entry
     pointing to the same handler/meta as the target route

2. **Alias resolution in `findRoute()`:**
   - When a route has `alias`, resolve to the aliased route's handler
   - Keep the URL unchanged (unlike redirect which changes URL)

3. **Redirect is already implemented** — just ensure it works with the new alias system

---

## Issue #72 — Navigation Loading State

**Current behavior:** `router.loading` pulse exists but is only set during async
component resolution in `outlet()`. It's not set during lazy loads or async guards.

### API Design

```javascript
// Reactive loading state
router.loading.get(); // true during lazy load or async guards

// Use in UI for NProgress-style bars
effect(() => {
  if (router.loading.get()) NProgress.start();
  else NProgress.done();
});

// Loading events for more granular control
router.onLoadingChange((loading) => {
  if (loading) showSpinner();
  else hideSpinner();
});
```

### Implementation

1. **Set `isLoading` to `true`** at the START of `navigate()` when:
   - The matched route uses `lazy()` (check if handler is a lazy handler)
   - Any guard is async (returns a Promise)
   - Middleware is configured

2. **Set `isLoading` to `false`** when:
   - Navigation completes (all guards + rendering done)
   - Navigation is aborted/redirected

3. **Add `onLoadingChange(callback)`** — Returns unsubscribe function.
   Simple wrapper: `effect(() => callback(isLoading.get()))`

4. **Ensure loading is always reset** — Use try/finally in navigate()

---

## Issue #71 — Route Groups for Shared Layouts

**Current behavior:** Nested routes exist but require a parent route with a URL segment.
No way to group routes under a layout without affecting the URL.

### API Design

```javascript
const router = createRouter({
  routes: {
    '/': HomePage,
    '/login': LoginPage,

    // Route group: shared layout, no URL prefix
    _admin: {
      group: true,
      layout: AdminLayout,
      children: {
        '/dashboard': DashboardPage,
        '/users': UsersPage,
        '/settings': SettingsPage
      }
    },

    // Another group
    _public: {
      group: true,
      layout: PublicLayout,
      children: {
        '/about': AboutPage,
        '/contact': ContactPage
      }
    }
  }
});
```

### Implementation

1. **In `compileRoutes()`:**
   - Detect `group: true` in config
   - Compile children with NO parent path prefix (group key is ignored for URL)
   - Attach `layout` reference to each child route

2. **In `outlet()`:**
   - When rendering a route with a layout, wrap the component:
     ```javascript
     const view = layout(routeComponent);
     ```
   - Cache layout instances to avoid re-creating on same-group navigation

3. **Group keys must start with `_`** to distinguish from URL patterns

---

## Issue #66 — Route Transitions and Lifecycle Hooks

### API Design

```javascript
// Per-route lifecycle hooks (registered in component code)
import { onBeforeLeave, onAfterEnter } from 'pulse-js-framework/runtime/router';

function EditPage(ctx) {
  // Confirm before leaving (e.g., unsaved changes)
  onBeforeLeave(() => {
    if (hasUnsavedChanges()) {
      return confirm('Discard changes?'); // false blocks navigation
    }
    return true;
  });

  // Post-navigation hook
  onAfterEnter(() => {
    analytics.track('page_view', { page: ctx.path });
  });

  return el('div', 'Edit Page');
}

// CSS transition classes on outlet
const router = createRouter({
  routes,
  transition: {
    enterClass: 'route-enter',          // Added when new route enters
    enterActiveClass: 'route-enter-active', // Added next frame for animation
    leaveClass: 'route-leave',          // Added when old route leaves
    leaveActiveClass: 'route-leave-active', // Added next frame for animation
    duration: 300                       // Max transition duration (ms)
  }
});
```

### Implementation

1. **`onBeforeLeave(callback)`** — Exported function:
   - Registers callback on the current route context
   - Called before `navigate()` proceeds (after guards, before URL change)
   - If returns `false`, navigation is blocked
   - Returns unsubscribe function

2. **`onAfterEnter(callback)`** — Exported function:
   - Registers callback on the current route context
   - Called after route component is mounted in outlet
   - Returns unsubscribe function

3. **CSS transitions in `outlet()`:**
   - On route change: add `leaveClass` to old view, `enterClass` to new view
   - Next frame: add `*-active` classes
   - After `duration` ms: remove all transition classes, remove old view
   - Use `requestAnimationFrame` for frame-accurate class application

4. **Lifecycle registry** — Internal Map keyed by route path:
   ```javascript
   const beforeLeaveHooks = new Map(); // path → [callbacks]
   const afterEnterHooks = new Map();  // path → [callbacks]
   ```

---

## Security Considerations

1. **Query parameter parsing** (#70):
   - Existing DoS limits (2KB total, 1KB per value, 50 params) are preserved
   - Typed parsing only for simple types (number, boolean) — no eval/Function
   - Array support bounded by existing maxParams limit

2. **Alias resolution** (#68):
   - Prevent alias loops (A → B → A) with visited-set check
   - Aliases cannot reference external URLs (must start with `/`)

3. **Transition classes** (#66):
   - CSS class names are sanitized (no injection via route config)
   - Duration capped at 10000ms to prevent DoS

4. **Loading state** (#72):
   - `isLoading` always reset in `finally` block to prevent stuck state

---

## Test Plan

Each issue gets a dedicated `describe()` block in `test/router.test.js`:

| Issue | Test Count | Focus Areas |
|-------|-----------|-------------|
| #73 | 4 | back/forward with scroll save, go(delta), promise resolution |
| #70 | 8 | Array params, typed parsing, encoding, edge cases |
| #68 | 6 | Static alias, dynamic alias, alias loops, alias + redirect |
| #72 | 5 | Loading during lazy, loading during guards, loading reset on abort |
| #71 | 6 | Group compilation, layout wrapping, nested groups, group + guard |
| #66 | 8 | onBeforeLeave block, onAfterEnter fire, CSS classes, transition timing |
| **Total** | **~37** | |

---

## Files Modified

| File | Changes |
|------|---------|
| `runtime/router.js` | All 6 features implemented here |
| `test/router.test.js` | ~37 new tests |
| `CLAUDE.md` | Updated router API documentation |
| `docs/milestones/v1.8.2-plan.md` | This plan |
